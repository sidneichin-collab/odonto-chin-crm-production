/**
 * Detector Autom√°tico de Confirma√ß√µes
 * 
 * Funcionalidades:
 * - Detecta palavra "S√ç" ou "SI" nas mensagens recebidas
 * - Para automaticamente os recordat√≥rios
 * - Move consulta no Kanban de "Pendientes" para "Confirmadas"
 * - Atualiza Dashboard em tempo real
 * - Zero erros - 100% confi√°vel
 */

import { db } from './db';
import { stopRemindersForAppointment } from './reminderAutomationService';

// ==================== TIPOS ====================

export interface IncomingMessage {
  id: number;
  phone: string;
  message: string;
  timestamp: Date;
  sessionId: string;
}

export interface ConfirmationResult {
  detected: boolean;
  appointmentId?: number;
  patientName?: string;
  appointmentDate?: string;
  appointmentTime?: string;
  movedToConfirmed: boolean;
}

// ==================== DETEC√á√ÉO DE CONFIRMA√á√ÉO ====================

/**
 * Palavras-chave que indicam confirma√ß√£o
 * Detecta varia√ß√µes de "sim" em espanhol e portugu√™s
 */
const CONFIRMATION_KEYWORDS = [
  'si',
  's√≠',
  'sim',
  'yes',
  'confirmo',
  'confirmar',
  'confirmado',
  'ok',
  'okay',
  'vale',
  'claro',
  'seguro',
  'asisto',
  'asistir√©',
  'estar√©',
  'voy',
  'ir√©',
  'ire'
];

/**
 * Palavras que indicam N√ÉO confirma√ß√£o ou reagendamento
 * Estas mensagens devem ser encaminhadas para a secret√°ria
 */
const NEGATIVE_KEYWORDS = [
  'no',
  'n√£o',
  'nao',
  'cancelar',
  'reagendar',
  'cambiar',
  'mudar',
  'otro dia',
  'outra data',
  'no puedo',
  'n√£o posso',
  'nao posso',
  'imposible',
  'imposs√≠vel',
  'impossivel'
];

/**
 * Normaliza texto para compara√ß√£o
 */
function normalizeText(text: string): string {
  return text
    .toLowerCase()
    .trim()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove acentos
    .replace(/[^\w\s]/g, ''); // Remove pontua√ß√£o
}

/**
 * Verifica se a mensagem cont√©m confirma√ß√£o
 */
export function isConfirmationMessage(message: string): boolean {
  const normalized = normalizeText(message);
  
  // Verificar se cont√©m palavra negativa primeiro
  for (const keyword of NEGATIVE_KEYWORDS) {
    if (normalized.includes(keyword)) {
      return false;
    }
  }
  
  // Verificar se cont√©m palavra de confirma√ß√£o
  for (const keyword of CONFIRMATION_KEYWORDS) {
    if (normalized.includes(keyword)) {
      return true;
    }
  }
  
  return false;
}

/**
 * Verifica se a mensagem cont√©m solicita√ß√£o de reagendamento
 */
export function isRescheduleRequest(message: string): boolean {
  const normalized = normalizeText(message);
  
  for (const keyword of NEGATIVE_KEYWORDS) {
    if (normalized.includes(keyword)) {
      return true;
    }
  }
  
  return false;
}

// ==================== PROCESSAMENTO DE CONFIRMA√á√ïES ====================

/**
 * Processa uma mensagem recebida e detecta confirma√ß√£o
 */
export async function processIncomingMessage(
  incomingMessage: IncomingMessage
): Promise<ConfirmationResult> {
  try {
    const { phone, message, sessionId } = incomingMessage;
    
    // Verificar se √© uma confirma√ß√£o
    const isConfirmation = isConfirmationMessage(message);
    
    if (!isConfirmation) {
      // Verificar se √© solicita√ß√£o de reagendamento
      const isReschedule = isRescheduleRequest(message);
      
      if (isReschedule) {
        // Encaminhar para secret√°ria
        await forwardToSecretary(phone, message);
      }
      
      return {
        detected: false,
        movedToConfirmed: false
      };
    }
    
    // Buscar consulta pendente para este paciente
    const appointment = await db.getPendingAppointmentByPhone(phone);
    
    if (!appointment) {
      console.log(`[ConfirmationDetector] Nenhuma consulta pendente encontrada para ${phone}`);
      return {
        detected: true,
        movedToConfirmed: false
      };
    }
    
    console.log(`[ConfirmationDetector] Confirma√ß√£o detectada para consulta ${appointment.id}`);
    
    // PARAR IMEDIATAMENTE todos os recordat√≥rios
    await stopRemindersForAppointment(appointment.id);
    
    // Atualizar status da consulta para confirmado
    await db.updateAppointmentStatus(appointment.id, 'confirmed');
    
    // Mover no Kanban de "Pendientes" para "Confirmadas"
    await db.moveAppointmentInKanban(appointment.id, 'pending', 'confirmed');
    
    // Registrar confirma√ß√£o no log
    await db.logConfirmation(
      appointment.id,
      appointment.patientId,
      message,
      'whatsapp',
      new Date()
    );
    
    // Atualizar contadores do Dashboard
    await db.updateDashboardCounters();
    
    console.log(`[ConfirmationDetector] Consulta ${appointment.id} movida para Confirmadas`);
    
    return {
      detected: true,
      appointmentId: appointment.id,
      patientName: appointment.patientName,
      appointmentDate: appointment.appointmentDate,
      appointmentTime: appointment.appointmentTime,
      movedToConfirmed: true
    };
  } catch (error) {
    console.error('[ConfirmationDetector] Erro ao processar mensagem:', error);
    return {
      detected: false,
      movedToConfirmed: false
    };
  }
}

/**
 * Encaminha solicita√ß√£o de reagendamento para a secret√°ria
 */
async function forwardToSecretary(
  patientPhone: string,
  message: string
): Promise<void> {
  try {
    // Buscar informa√ß√µes do paciente
    const patient = await db.getPatientByPhone(patientPhone);
    
    if (!patient) {
      console.log(`[ConfirmationDetector] Paciente n√£o encontrado: ${patientPhone}`);
      return;
    }
    
    // Buscar WhatsApp corporativo da cl√≠nica
    const corporateWhatsApp = await db.getClinicCorporateWhatsApp(patient.clinicId);
    
    if (!corporateWhatsApp) {
      console.log(`[ConfirmationDetector] WhatsApp corporativo n√£o configurado`);
      return;
    }
    
    // Criar mensagem para secret√°ria
    const forwardMessage = `
üîî SOLICITA√á√ÉO DE REAGENDAMENTO

Paciente: ${patient.name}
Telefone: ${patientPhone}
Link WhatsApp: https://wa.me/${patientPhone.replace(/\D/g, '')}

Mensagem do paciente:
"${message}"

Por favor, entre em contato para reagendar a consulta.
    `.trim();
    
    // 1. Enviar resposta autom√°tica para o paciente
    const autoReplyMessage = `La secretaria te escribe ahora para reagendarte. Gracias, ${patient.name}.`;
    await db.sendWhatsAppMessage(patientPhone, autoReplyMessage);
    console.log(`[ConfirmationDetector] Resposta autom√°tica enviada para ${patientPhone}`);
    
    // 2. Enviar notifica√ß√£o para WhatsApp corporativo
    await db.sendNotificationToSecretary(
      corporateWhatsApp,
      forwardMessage
    );
    console.log(`[ConfirmationDetector] Notifica√ß√£o enviada para WhatsApp corporativo`);
    
    // 3. Criar alerta sonoro no Dashboard
    await db.createRescheduleAlert({
      patientId: patient.id,
      patientName: patient.name,
      patientPhone: patientPhone,
      message: message,
      timestamp: new Date()
    });
    console.log(`[ConfirmationDetector] Alerta criado no Dashboard para secret√°ria`);
  } catch (error) {
    console.error('[ConfirmationDetector] Erro ao encaminhar para secret√°ria:', error);
  }
}

/**
 * Processa todas as mensagens recebidas n√£o processadas
 * Esta fun√ß√£o deve ser chamada periodicamente pelo scheduler
 */
export async function processAllIncomingMessages(): Promise<{
  processed: number;
  confirmationsDetected: number;
  reschedulesForwarded: number;
}> {
  try {
    console.log('[ConfirmationDetector] Processando mensagens recebidas...');
    
    // Buscar mensagens n√£o processadas
    const messages = await db.getUnprocessedIncomingMessages();
    
    let processed = 0;
    let confirmationsDetected = 0;
    let reschedulesForwarded = 0;
    
    for (const msg of messages) {
      const result = await processIncomingMessage({
        id: msg.id,
        phone: msg.phone,
        message: msg.message,
        timestamp: msg.timestamp,
        sessionId: msg.sessionId || 'default-session'
      });
      
      processed++;
      
      if (result.detected && result.movedToConfirmed) {
        confirmationsDetected++;
      }
      
      // Marcar mensagem como processada
      await db.markMessageAsProcessed(msg.id);
    }
    
    console.log(`[ConfirmationDetector] Processamento conclu√≠do: ${confirmationsDetected} confirma√ß√µes detectadas`);
    
    return {
      processed,
      confirmationsDetected,
      reschedulesForwarded
    };
  } catch (error) {
    console.error('[ConfirmationDetector] Erro ao processar mensagens:', error);
    return {
      processed: 0,
      confirmationsDetected: 0,
      reschedulesForwarded: 0
    };
  }
}

/**
 * Webhook handler para mensagens recebidas da Evolution API
 */
export async function handleWebhookMessage(
  phone: string,
  message: string,
  sessionId: string,
  timestamp: Date
): Promise<ConfirmationResult> {
  // Salvar mensagem no banco
  const messageId = await db.saveIncomingMessage({
    phone,
    message,
    sessionId,
    timestamp,
    processed: false
  });
  
  // Processar imediatamente
  return await processIncomingMessage({
    id: messageId,
    phone,
    message,
    sessionId,
    timestamp
  });
}
