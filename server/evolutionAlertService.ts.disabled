import { notifyOwner } from '../_core/notification';

/**
 * SERVI√áO DE ALERTAS E RECONEX√ÉO AUTOM√ÅTICA
 * 
 * Responsabilidades:
 * 1. Enviar alertas ao dono quando Evolution falha
 * 2. Tentar reconectar automaticamente
 * 3. Registrar hist√≥rico de falhas
 * 4. Escalar alertas se problema persistir
 */

interface AlertEvent {
  timestamp: Date;
  type: 'warning' | 'critical' | 'resolved';
  message: string;
  failureCount: number;
}

class EvolutionAlertService {
  private alertHistory: AlertEvent[] = [];
  private alertThrottleMap: Map<string, Date> = new Map();
  private throttleDelayMs = 5 * 60 * 1000; // 5 minutos entre alertas do mesmo tipo

  /**
   * Registrar evento de alerta
   */
  async logAlert(type: 'warning' | 'critical' | 'resolved', message: string, failureCount: number) {
    const event: AlertEvent = {
      timestamp: new Date(),
      type,
      message,
      failureCount,
    };

    this.alertHistory.push(event);

    // Manter apenas √∫ltimas 100 alertas
    if (this.alertHistory.length > 100) {
      this.alertHistory = this.alertHistory.slice(-100);
    }

    console.log(`[EvolutionAlert] ${type.toUpperCase()}: ${message}`);
  }

  /**
   * Enviar alerta ao dono (com throttle)
   */
  async sendAlert(type: 'warning' | 'critical', message: string, failureCount: number) {
    const throttleKey = `${type}`;
    const lastAlert = this.alertThrottleMap.get(throttleKey);
    const now = new Date();

    // N√£o enviar alertas muito frequentes do mesmo tipo
    if (lastAlert && now.getTime() - lastAlert.getTime() < this.throttleDelayMs) {
      console.log(`[EvolutionAlert] Alerta throttled: ${throttleKey}`);
      return;
    }

    this.alertThrottleMap.set(throttleKey, now);

    const title = type === 'critical' ? 'üö® CR√çTICO' : '‚ö†Ô∏è AVISO';
    const content = `${message}\n\nFalhas consecutivas: ${failureCount}\nHora: ${now.toLocaleString()}`;

    try {
      await notifyOwner({ title, content });
      await this.logAlert(type, message, failureCount);
    } catch (error) {
      console.error('[EvolutionAlert] Erro ao enviar notifica√ß√£o:', error);
    }
  }

  /**
   * Alerta de desconex√£o
   */
  async alertDisconnected(instanceName: string, failureCount: number) {
    if (failureCount === 1) {
      // Primeira falha - apenas warning
      await this.sendAlert(
        'warning',
        `Evolution API - Inst√¢ncia ${instanceName} desconectada`,
        failureCount
      );
    } else if (failureCount >= 3) {
      // Terceira falha ou mais - cr√≠tico
      await this.sendAlert(
        'critical',
        `Evolution API - Inst√¢ncia ${instanceName} OFFLINE!\n\nA√ß√£o necess√°ria:\n1. Acessar Evolution Manager\n2. Conectar WhatsApp novamente\n3. Verificar API Key`,
        failureCount
      );
    }
  }

  /**
   * Alerta de reconex√£o bem-sucedida
   */
  async alertReconnected(instanceName: string) {
    await this.logAlert('resolved', `Evolution API - Inst√¢ncia ${instanceName} reconectada`, 0);

    try {
      await notifyOwner({
        title: '‚úÖ Evolution API - Reconectada',
        content: `A inst√¢ncia ${instanceName} foi reconectada com sucesso.\n\nMensagens est√£o sendo enviadas normalmente.`,
      });
    } catch (error) {
      console.error('[EvolutionAlert] Erro ao enviar notifica√ß√£o de reconex√£o:', error);
    }
  }

  /**
   * Obter hist√≥rico de alertas
   */
  getAlertHistory(limit: number = 50): AlertEvent[] {
    return this.alertHistory.slice(-limit);
  }

  /**
   * Limpar hist√≥rico
   */
  clearHistory() {
    this.alertHistory = [];
    this.alertThrottleMap.clear();
  }

  /**
   * Obter estat√≠sticas
   */
  getStats() {
    const warnings = this.alertHistory.filter((a) => a.type === 'warning').length;
    const criticals = this.alertHistory.filter((a) => a.type === 'critical').length;
    const resolved = this.alertHistory.filter((a) => a.type === 'resolved').length;

    return {
      totalAlerts: this.alertHistory.length,
      warnings,
      criticals,
      resolved,
      lastAlert: this.alertHistory[this.alertHistory.length - 1] || null,
    };
  }
}

export const evolutionAlert = new EvolutionAlertService();
